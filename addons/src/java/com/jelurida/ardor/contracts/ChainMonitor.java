package com.jelurida.ardor.contracts;

import nxt.Constants;
import nxt.addons.AbstractContract;
import nxt.addons.ChainWrapper;
import nxt.addons.Contract;
import nxt.addons.ContractAndSetupParameters;
import nxt.addons.ContractRunnerParameter;
import nxt.addons.ContractSetupParameter;
import nxt.addons.DelegatedContext;
import nxt.addons.InitializationContext;
import nxt.addons.JO;
import nxt.addons.ShutdownContext;
import nxt.http.callers.GetBlockCall;
import nxt.http.callers.GetBlockchainStatusCall;
import nxt.http.callers.GetBlocksCall;
import nxt.http.callers.GetBundlerRatesCall;
import nxt.http.callers.GetUnconfirmedTransactionsCall;
import nxt.http.responses.BlockResponse;
import nxt.util.Convert;
import nxt.util.Logger;

import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Monitor the blockchain for unexpected conditions
 */
@SuppressWarnings("unused")
public class ChainMonitor extends AbstractContract<Object, Object> {
    // Duplicate of constants.java
    private static final int TESTNET_ACCELERATION = 6;
    private static final int TESTNET_ACCELERATION_BLOCK = 455000;

    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();

    private Contract<String, Integer> slackNotifier;
    private Contract<String, Integer> telegramNotifier;

    public interface Parameters {
        @ContractRunnerParameter
        String slackWebHookUrl();

        @ContractRunnerParameter
        @ContractSetupParameter
        default int refreshIntervalSeconds() { return 90; }

        @ContractRunnerParameter
        @ContractSetupParameter
        default int blockDelayMinutesMoreThan() { return 5; }

        @ContractRunnerParameter
        @ContractSetupParameter
        default int blocksBySameGenerator() { return 10; }

        @ContractRunnerParameter
        @ContractSetupParameter
        default int unconfirmedTransactionsCountHigherThan() { return 100; }
    }

    @Override
    public void init(InitializationContext context) {
        Parameters params = context.getParams(Parameters.class);
        ContractAndSetupParameters contractAndParameters = context.loadContract("SlackNotifier");
        slackNotifier = contractAndParameters.getContract();
        contractAndParameters = context.loadContract("TelegramNotifier");
        telegramNotifier = contractAndParameters.getContract();
        String slackWebHookUrl = params.slackWebHookUrl();
        JO slackNotifierSetup = null;
        if (slackWebHookUrl != null) {
            slackNotifierSetup = new JO();
            slackNotifierSetup.put("slackWebHookUrl", slackWebHookUrl);
        }
        DelegatedContext delegatedContext = new DelegatedContext(context, "SlackNotifier", slackNotifierSetup);
        int delay = params.refreshIntervalSeconds();
        scheduler.scheduleWithFixedDelay(() -> monitor(params, delegatedContext), delay / 2, delay, TimeUnit.SECONDS);
    }

    private void monitor(Parameters parameters, DelegatedContext delegatedContext) {
        Logger.logInfoMessage("Chain monitor started");
        try {
            // Check that there is no big delay between subsequent blocks
            JO status = GetBlockchainStatusCall.create().call();
            BlockResponse blockResponse = BlockResponse.create(GetBlockCall.create().call());
            int height = blockResponse.getHeight();
            boolean isTestnet = status.getBoolean("isTestnet");
            String prefix = String.format("%s height %d -", delegatedContext.getNetworkType(), height);
            if (!status.getBoolean("isDownloading")) {
                int currentTime = Convert.toEpochTime(System.currentTimeMillis());
                int blockTimestamp = blockResponse.getTimestamp();
                if (currentTime - blockTimestamp > 60 * parameters.blockDelayMinutesMoreThan()) {
                    String message = String.format("%s no blocks for more than %d seconds, last known block %s", prefix, currentTime - blockTimestamp, Long.toUnsignedString(blockResponse.getBlockId()));
                    slackNotifier.processInvocation(delegatedContext, message);
                    telegramNotifier.processInvocation(delegatedContext, message);
                }
            }

            // Check that last X blocks were not all generated by the same forger
            JO response = GetBlocksCall.create().firstIndex(0).lastIndex(parameters.blocksBySameGenerator() - 1).call();
            Set<Long> generators = response.getJoList("blocks").stream().map(blockJson -> BlockResponse.create(blockJson).getGeneratorId()).collect(Collectors.toSet());
            if (generators.size() == 1) {
                String message = String.format("%s last %d blocks generated by the same forger", prefix, parameters.blocksBySameGenerator());
                slackNotifier.processInvocation(delegatedContext, message);
                telegramNotifier.processInvocation(delegatedContext, message);
            }

            // Check at least 10% of the stake is forging
            long percent = 100L * blockResponse.getBaseTarget() / Constants.INITIAL_BASE_TARGET;
            if (isTestnet && blockResponse.getHeight() > TESTNET_ACCELERATION_BLOCK) {
                percent /= TESTNET_ACCELERATION; // Reflect change of block time to 10 seconds on testnet
            }
            if (percent > 1000L) {
                String message = String.format("%s base target percent %s is higher than threshold. Check that the blockchain did not fork", prefix, percent);
                slackNotifier.processInvocation(delegatedContext, message);
                telegramNotifier.processInvocation(delegatedContext, message);
            }

            // Check that there is no accumulation of unconfirmed transactions
            int unconfirmedCounter = GetUnconfirmedTransactionsCall.create().call().size();
            if (unconfirmedCounter > parameters.unconfirmedTransactionsCountHigherThan()) {
                String message = String.format("%s number of unconfirmed transactions %d is higher than threshold", prefix, unconfirmedCounter);
                slackNotifier.processInvocation(delegatedContext, message);
                telegramNotifier.processInvocation(delegatedContext, message);
            }

            // Check that all chains has bundlers
            JO bundlerRates = GetBundlerRatesCall.create().call();
            List<JO> rates = bundlerRates.getJoList("rates");
            if (rates.size() > 0) {
                Set<Integer> bundlerChains = rates.stream().collect(Collectors.toMap(k -> k.getInt("chain"), k -> k)).keySet(); // set of unique chain ids
                int chainId = 2;
                ChainWrapper chain;
                while ((chain = delegatedContext.getChain(chainId)) != null) {
                    if (!chain.isEnabled() || chainId == 3) {
                        chainId++;
                        continue;
                    }
                    if (!bundlerChains.contains(chainId)) {
                        String message = String.format("%s chain %d has no bundlers", prefix, chainId);
                        slackNotifier.processInvocation(delegatedContext, message);
                        telegramNotifier.processInvocation(delegatedContext, message);
                    }
                    chainId++;
                }
            } else {
                Logger.logInfoMessage(String.format("%s bundler rates not loaded", prefix));
            }
            Logger.logInfoMessage("Chain monitor done");
        } catch (Throwable t) {
            Logger.logErrorMessage("Chain monitor error", t);
        }
    }

    @Override
    public void shutdown(ShutdownContext context) {
        context.shutdown(scheduler);
    }
}
